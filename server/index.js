import express from 'express';
import cors from 'cors';
import axios from 'axios';
import { TextToSpeechClient } from '@google-cloud/text-to-speech';
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const port = process.env.PORT || 3000;

app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

app.use(cors({
  methods: ['GET', 'POST', 'OPTIONS'],
  maxAge: 600,
}));

const ttsClient = new TextToSpeechClient({
  keyFilename: path.join(__dirname, 'google-credentials.json'),
});

const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

const CONCISE_PROMPT = `Act as a highly experienced and approachable university professor who is teaching this topic to students for the first time...`;
const DETAILED_PROMPT = `Act as a senior university professor or experienced lecturer who is highly skilled in teaching this subject to students...`;

app.use(express.static(path.join(__dirname, '..', 'public')));

async function ensureAudioFolder() {
  const audioPath = path.join(__dirname, '..', 'public', 'audio');
  await fs.mkdir(audioPath, { recursive: true });
}

async function generateLectureScript(content, style) {
  const finalPrompt = `
${style === 'concise' ? CONCISE_PROMPT : DETAILED_PROMPT}

Content to convert into a lecture:
${content}
  `;

  try {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent`;

    const response = await axios.post(
      url,
      {
        contents: [
          {
            parts: [{ text: finalPrompt }]
          }
        ]
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Goog-Api-Key': GEMINI_API_KEY
        },
        timeout: 60000
      }
    );

    const candidate = response.data?.candidates?.[0]?.content;
    const text = candidate?.parts?.[0]?.text;

    if (!text || typeof text !== 'string') {
      throw new Error('Gemini returned an empty or invalid response');
    }

    return text;
  } catch (err) {
    console.error('[Gemini Error]', err.response?.data || err.message);
    throw new Error(`Gemini API error: ${err.message}`);
  }
}

// NEW TTS FUNCTION WITH CHUNKING
async function textToSpeechLong(script, voice, userId, noteId, normalizedTitle, style) {
  try {
    function chunkText(text, maxBytes = 4500) {
      const chunks = [];
      let current = '';
      for (const paragraph of text.split('\n')) {
        if (Buffer.byteLength(current + '\n' + paragraph, 'utf8') > maxBytes) {
          chunks.push(current);
          current = paragraph;
        } else {
          current += '\n' + paragraph;
        }
      }
      if (current) chunks.push(current);
      return chunks;
    }

    const chunks = chunkText(script);
    const audioBuffers = [];

    for (const chunk of chunks) {
      const [response] = await ttsClient.synthesizeSpeech({
        input: { text: chunk },
        voice: { languageCode: 'en-US', name: voice },
        audioConfig: { audioEncoding: 'MP3', pitch: 0, speakingRate: 1 },
      });

      if (!response.audioContent) {
        throw new Error('No audio content generated by TTS for a chunk');
      }

      audioBuffers.push(Buffer.from(response.audioContent));
    }

    const finalAudio = Buffer.concat(audioBuffers);

    const baseDir = path.join(__dirname, '..', 'public', 'audio', userId, noteId);
    await fs.mkdir(baseDir, { recursive: true });

    const audioFile = path.join(baseDir, `audio-${style}.mp3`);
    await fs.writeFile(audioFile, finalAudio);

    const userDir = path.join(__dirname, '..', 'public', 'audio', userId);
    const dirs = await fs.readdir(userDir);
    if (dirs.length > 5) {
      const stats = await Promise.all(
        dirs.map(async (dir) => {
          const stat = await fs.stat(path.join(userDir, dir));
          return { dir, mtime: stat.mtime.getTime() };
        })
      );
      const toDelete = stats.sort((a, b) => a.mtime - b.mtime).slice(0, dirs.length - 5);
      for (const { dir } of toDelete) {
        await fs.rm(path.join(userDir, dir), { recursive: true, force: true });
        console.log(`ðŸ§¹ Deleted old audio folder: ${dir}`);
      }
    }

    return `/audio/${userId}/${noteId}/audio-${style}.mp3`;
  } catch (err) {
    console.error('[TTS Error]', err);
    throw new Error(`TTS error: ${err.message}`);
  }
}

app.post('/api/generate-audio', async (req, res) => {
  try {
    const { userId, noteId, normalizedTitle, style, noteContent, rawText } = req.body;
    const voice = 'en-US-Studio-O';

    if (!userId || !noteId || !normalizedTitle || !style || !noteContent) {
      return res.status(400).json({ error: 'Missing required parameters' });
    }

    const fullContent = rawText
      ? `${noteContent}\n\nOriginal Source Material:\n${rawText}`
      : noteContent;

    const script = await generateLectureScript(fullContent, style);

    const audioUrl = await textToSpeechLong(script, voice, userId, noteId, normalizedTitle, style);

    res.json({
      audioUrl,
      script,
      style,
      voice,
      generatedAt: Date.now(),
    });
  } catch (error) {
    console.error('Audio generation failed:', error);
    res.status(500).json({ error: error.message || 'Failed to generate audio' });
  }
});

app.get('/audio/:userId/:noteId/:filename', (req, res) => {
  const { userId, noteId, filename } = req.params;
  const filePath = path.join(__dirname, '..', 'public', 'audio', userId, noteId, filename);
  res.sendFile(filePath);
});

async function startServer() {
  await ensureAudioFolder();
  app.listen(port, () => {
    console.log(`ðŸš€ Server running at http://localhost:${port}`);
  });
}

startServer();
