import express from 'express';
import cors from 'cors';
import axios from 'axios';
import { TextToSpeechClient } from '@google-cloud/text-to-speech';
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';

// Load .env
dotenv.config();

// Resolve __dirname for ES Modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const port = process.env.PORT || 3000;

// Increase payload limits for large PDFs
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// Configure CORS with increased timeout
app.use(cors({
  methods: ['GET', 'POST', 'OPTIONS'],
  maxAge: 600, // Increase preflight cache to 10 minutes
}));

// Hardcode the path to credentials so TTS definitely finds them
const ttsClient = new TextToSpeechClient({
  keyFilename: path.join(__dirname, 'google-credentials.json'),
});

// Pull your Gemini API key from .env
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

// Example Prompts
const CONCISE_PROMPT = `Act as a highly experienced and approachable university professor who is teaching this topic to students for the first time...`;
const DETAILED_PROMPT = `Act as a senior university professor or experienced lecturer who is highly skilled in teaching this subject to students...`;

app.use(express.static(path.join(__dirname, '..', 'public')));

/** Ensure the top-level audio folder exists. */
async function ensureAudioFolder() {
  const audioPath = path.join(__dirname, '..', 'public', 'audio');
  await fs.mkdir(audioPath, { recursive: true });
}

/**
 * Generate a lecture script from the Gemini API (REST approach).
 */
async function generateLectureScript(content, style) {
  // Pick the correct prompt
  const finalPrompt = `
${style === 'concise' ? CONCISE_PROMPT : DETAILED_PROMPT}

Content to convert into a lecture:
${content}
  `;

  try {
    // Make direct HTTP POST to the Gemini v1beta API with gemini-1.5-pro
    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent`;

    const response = await axios.post(
      url,
      {
        contents: [
          {
            parts: [
              { text: finalPrompt }
            ]
          }
        ]
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Goog-Api-Key': GEMINI_API_KEY
        },
        // Add timeout for large requests
        timeout: 60000 // 60 second timeout
      }
    );

    // Typically returns candidates[].content.parts[].text
    const candidate = response.data?.candidates?.[0]?.content;
    const text = candidate?.parts?.[0]?.text;

    if (!text || typeof text !== 'string') {
      throw new Error('Gemini returned an empty or invalid response');
    }

    return text;
  } catch (err) {
    console.error('[Gemini Error]', err.response?.data || err.message);
    throw new Error(`Gemini API error: ${err.message}`);
  }
}

/**
 * Convert the lecture script to audio via Google TTS,
 * then save it in /public/audio/{userId}/{noteId}/audio-{style}.mp3
 */
async function textToSpeech(script, voice, userId, noteId, normalizedTitle, style) {
  try {
    const request = {
      input: { text: script },
      voice: {
        languageCode: 'en-US',
        name: voice,
      },
      audioConfig: {
        audioEncoding: 'MP3',
        pitch: 0,
        speakingRate: 1,
      },
    };

    const [response] = await ttsClient.synthesizeSpeech(request);
    if (!response.audioContent) {
      throw new Error('No audio content generated by TTS');
    }

    // Create user/note directories
    const baseDir = path.join(__dirname, '..', 'public', 'audio', userId, noteId);
    await fs.mkdir(baseDir, { recursive: true });

    // Save the MP3
    const audioFile = path.join(baseDir, `audio-${style}.mp3`);
    await fs.writeFile(audioFile, response.audioContent);

    // Keep only 5 note folders per user
    const userDir = path.join(__dirname, '..', 'public', 'audio', userId);
    const dirs = await fs.readdir(userDir);
    if (dirs.length > 5) {
      const stats = await Promise.all(
        dirs.map(async (dir) => {
          const stat = await fs.stat(path.join(userDir, dir));
          return { dir, mtime: stat.mtime.getTime() };
        })
      );
      const toDelete = stats.sort((a, b) => a.mtime - b.mtime).slice(0, dirs.length - 5);
      for (const { dir } of toDelete) {
        await fs.rm(path.join(userDir, dir), { recursive: true, force: true });
        console.log(`ðŸ§¹ Deleted old audio folder: ${dir}`);
      }
    }

    return `/audio/${userId}/${noteId}/audio-${style}.mp3`;
  } catch (err) {
    console.error('[TTS Error]', err);
    throw new Error(`TTS error: ${err.message}`);
  }
}

/**
 * POST /api/generate-audio
 * Takes userId, noteId, style, noteContent, rawText, etc.
 * 1. Generate script from Gemini
 * 2. Convert to audio via TTS
 * 3. Return audio file URL + script
 */
app.post('/api/generate-audio', async (req, res) => {
  try {
    const { userId, noteId, normalizedTitle, style, noteContent, rawText } = req.body;
    const voice = 'en-US-Studio-O';

    // Basic validation
    if (!userId || !noteId || !normalizedTitle || !style || !noteContent) {
      return res.status(400).json({ error: 'Missing required parameters' });
    }

    // Combine note content + raw text for the final prompt
    const fullContent = rawText
      ? `${noteContent}\n\nOriginal Source Material:\n${rawText}`
      : noteContent;

    // 1) Gemini script
    const script = await generateLectureScript(fullContent, style);

    // 2) Convert to audio
    const audioUrl = await textToSpeech(script, voice, userId, noteId, normalizedTitle, style);

    res.json({
      audioUrl,
      script,
      style,
      voice,
      generatedAt: Date.now(),
    });
  } catch (error) {
    console.error('Audio generation failed:', error);
    res.status(500).json({ error: error.message || 'Failed to generate audio' });
  }
});

/**
 * GET /audio/:userId/:noteId/:filename
 * Serve the static audio files
 */
app.get('/audio/:userId/:noteId/:filename', (req, res) => {
  const { userId, noteId, filename } = req.params;
  const filePath = path.join(__dirname, '..', 'public', 'audio', userId, noteId, filename);
  res.sendFile(filePath);
});

/** Start the server */
async function startServer() {
  await ensureAudioFolder();
  app.listen(port, () => {
    console.log(`ðŸš€ Server running at http://localhost:${port}`);
  });
}

startServer();